# SpringTest1
Проверка решений циклической зависимости, решения проблемы неоднозначности выбора бинов при их инициализации, 
создание собственного BeanPostProcessor, применение аннотаций при создании контекста в Spring.
Задание:
Написать проект на spring(НЕ spring-boot)
Конфигурация контекста - какая больше нравится
Сделать Интерфейс Parent, сделать два класса, которые будут его имплементить Father и Mother. 
У папы есть поле wife, у мамы husband. В них инжектим father и mother. 
Попробовать все виды инжекта и посмотреть, что будет. 
Решить проблему, которая возникнет (циклическая зависимость)
Далее сделать бин SchoolMeet, в который будет инджектиться Parent. Посмотреть, что будет. 
Решить возникшую проблему
Далее будет бин Child типа prototype. Пусть у него будет номер, которые генерируется только при создании. 
Номер - рандомное число. Ну и метод, чтобы вывести этот номер. У мамы или папы также заинжектить ребенка и написать метод, которые будет выводить номер ребенка. 
Суть в том, что прототип должен будет каждый раз генерироваться заново, следовательно каждый раз должно быть новое число 

Необходимо создать два бина, в которых выводить:
Что отработал констурктор
Что отработал init method
Создать свой BPP, в котором будет выводится, что отработал BPPBeforeInitialization и BPPAfterInitialization 

Выполнены следующие шаги в результате работы над проектом:
        Шаг 1 - получение циклической зависимости при указании Autowired у сеттера, поля класса и конструктора
        На циклическую зависимость указывает исключение: UnsatisfiedDependencyException - Is there an unresolvable circular reference?
      
        Шаг 2 - решение проблемы циклической зависимости с помощью:
         Вариант 1 - аннотации Lazy, применяемой к одному из конструкторов
         Вариант 2 - применение аннотаций Autowired и PostConstruct в одном из классов-бинов.
         Применение метода init для создания зависимости от второго бина, применение конструкторов по умолчанию
         Вариант 3 - применение реализации интерфейсов ApplicationContextAware, InitializingBean
         в одном из бинов с целью получения из контекста экземпляра другого бина
         Вариант 4 -  изменение структуры проекта таким образом, чтобы бины не имели циклической зависимости,
         например, созданием дополнительного класса, куда будут внедряться зависимые друг от друга бины
  
        Шаг 3 - получение исключения NoUniqueBeanDefinitionException при создании бина SchoolMeet при инжекции
        бина типа Parent в бин типа SchoolMeet

        Шаг 4 - решение проблемы неоднозначности опредления бина и исключения NoUniqueBeanDefinitionException с помощью:
         Вариант 1: аннотации @Primary, поставленной над классом одного из бинов
         Вариант 2: аннотации Qualifier, поставленной над аргументом бина в конструкторе, в котором происходит исключение
           
        Шаг 5 - внедрение бина с областью видимости prototype в бин с областью видимости singleton
        Получение нового номера каждый раз при вызове конструктора бина Child.
        Использование аннотации Lookup в классе Mother для получения бина с областью видимости prototype в методе бина
        с областью видимости singleton
        
        Шаг 6 - внедрение бина с областью видимости prototype в бин с областью видимости singleton
        Использование аннотации Lookup для получения бина с областью видимости prototype в методе бина
        с областью видимости singleton
      
        Шаг 7 - создание собственной реализации BeanPostProcessor
        Класс FamilyBeanPostProcessor с аннотацией в бине Family
Более подробно выполнение шагов выполнено в коде в виде комментариев.
